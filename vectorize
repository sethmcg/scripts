#!/bin/tcsh -fx

## given a file of commands (one command per line), runs them in
## parallel on cheyenne using commandfile MPMD approach

set defaultq = yes
set help = no
set submit = yes
set QUEUE = economy
set defaulte = yes
set defaultm = yes
# set MEMORY = 2G
set memory = no
set WALLTIME = 00:10:00


## Argument parsing from util-linux-ng getopt-parse.tcsh example.

# Use a temp variable b/c eval nukes getopt return value.  ':q' copies
# argv list w/ no substitutions

set temp=(`getopt -a -n vectorize -s tcsh -o d:e:ghj:m:np:q:sw: --long dir:,env:,help,nosub,memory:,project:,queue:,walltime: -- $argv:q`)
if ($? != 0) then
  echo "Terminating..." >/dev/stderr
  exit 1
endif

# Quote the parens b/c the result is a list, and they need to be
# evaluated when eval is called.  'q' prevents substitutions.

eval set argv=\($temp:q\)

while (1)
  switch($1:q)
  case -d:
  case --dir:
    set dir = $2:q ; shift ; shift
    breaksw;
  case -e:
  case --env:
    set defaulte = no
    set env = $2:q ; shift ; shift
    breaksw;
  case -h:
    set help = yes ; shift
    breaksw
  case -j:
  case --jobname:
    set JOBNAME = $2:q ; shift ; shift
    breaksw;
  case -m:
  case --memory:
    set defaultm = no
    set MEMORY = $2:q ; shift ; shift
    breaksw;
  case -n:
  case --nosub:
    set submit = no ; shift
    breaksw 
  case -p:
  case --project:
    set PROJECT = $2:q ; shift ; shift
    breaksw;
  case -q:
  case --queue:
    set defaultq = no
    set QUEUE = $2:q ; shift ; shift
    breaksw;
  case -w:
  case --walltime:
    set WALLTIME = $2:q ; shift ; shift
    breaksw;
  case --:
    shift
    break
  default:
    echo "vectorize: Internal error!" ; exit 1
    endsw
end


if(! $?PROJECT) then
  set PROJECT = none
  echo "vectorize: ERROR: project code not defined"
endif

if( $#argv < 1) then
  echo "vectorize: ERROR: no commandfile"  
endif

if( $#argv > 1) then
  echo "vectorize: ERROR: too many arguments"
endif

if($help == yes || $PROJECT == none || $#argv != 1) then
  cat <<EOUSAGE
Usage: vectorize [-d dir] [-h] [-j jobname] [-n] [-p project] [-q queue] [-w walltime] cmdfile
  -d, --dir:       directory for output; defaults to \`mktemp -d\`
  -e, --env:       environment file; defaults to ~/.vectorize/<queue>
  -h, --help:      prints this help message
  -j, --jobname:   qsub jobname; defaults to `basename cmdfile .txt`
  -m, --memory:    memory needed in GB (only useful with -s or -q)
  -n, --nosub:     don't submit job, just set everything up
  -p, --project:   project code; defaults to PROJECT envariable (if set)
  -q, --queue:     queue to submit to; defaults to 'economy'
  -w, --walltime:  wallclock limit for job; defaults to 00:10:00
  cmdfile: a file with one command per line, to be run in parallel

  vectorize is a utility for running many independent single-threaded
  commands in parallel on cheyenne using MPDP parallelism.
EOUSAGE
exit 1
endif

## bail out early if no command file

if (-z $1) then
  echo "vectorize: ERROR: empty command file; exiting"
  exit 1
endif
if (! -e $1) then
  echo "vectorize: ERROR: no such command file: '$1'; exiting"
  exit 1
endif


## if not specified, set environment based on queue
if ($defaulte == yes) then
  set env = "~/.vectorize/$QUEUE"
endif

if (! -e $env) then
  if ($defaulte == yes) then
    echo "vectorize: ERROR: no default environment for queue '$QUEUE'; exiting"
    echo "To resolve this error, create file ~/.vectorize/$QUEUE containing"
    echo "any 'module load' commands, etc. needed in the PBS script."
  else 
    echo "vectorize: ERROR: no such environment file: '$env'; exiting"
  endif
  exit 1
endif

## test for mutually exclusive flags


## create output dir

if ( $?dir ) then
  mkdir -p $dir
else
  set dir = `mktemp -d`
endif


## setup

if (! $?JOBNAME ) then
  set JOBNAME = `basename $1 .txt`
endif

set CMDFILE = $dir/cmd
set OUTFILE = $dir/out
set ERRFILE = $dir/err
set pbsfile = $dir/pbs


## commands need to be wrapped in a shell invocation for MPMD
## but not for running in share queue or on casper

if ($QUEUE == share || $QUEUE == casper) then
  cp $1 $CMDFILE
else 
  sed "s|\(.*\)|bash -c '\1'|g" $1 > $CMDFILE
endif


## create PBS batch script

cat <<EOPBSHEAD > $pbsfile
#!/bin/tcsh

##### parameters for PBS scheduling via qsub
##### submit jobs as "qsub scriptname"

# account code to charge to
#PBS -A $PROJECT

# which queue to use
#PBS -q $QUEUE

# job name
#PBS -N $JOBNAME

# stdout file
#PBS -o $OUTFILE

# stderr file
#PBS -e $ERRFILE

# runtime limit
#PBS -l walltime=$WALLTIME

EOPBSHEAD

# if ($serial == yes) then
# 
#   if ($defaultm == no) then
#     set memstring = ":mem=${MEMORY}GB"
#   else
#     set memstring = ""
#   endif
# 
#   cat <<EOSERIAL >> $pbsfile
# # CPU resource request for serial job in shared queue
# #PBS -l select=1:ncpus=1$memstring
# EOSERIAL
# 
# else

set NTASK = `cat $CMDFILE | wc -l`
set NNODE = `perl -w -e "use POSIX; print ceil($NTASK/36)"`
set NCPUS = `perl -w -e "use POSIX; print ceil($NTASK/$NNODE)"`

  cat <<EOPARALLEL >> $pbsfile
# CPU resource request
# ntask = number of lines in file [$NTASK]
# nnode = ceiling(ntask / 36)     [$NNODE]
# ncpus = ceiling(ntask / nnode)  [$NCPUS]
# select: number of nodes
# ncpus: number of cpus per node to use
# mpiprocs: matches ncpus (1 process per CPU)
# ompthreads: always set to 1 (1 thread per process)
#PBS -l select=${NNODE}:ncpus=${NCPUS}:mpiprocs=${NCPUS}:ompthreads=1
EOPARALLEL

endif

  cat <<EOPBSMID >> $pbsfile

#source /glade/u/apps/opt/lmod/4.2.1/init/tcsh 

setenv TMPDIR /glade/scratch/$USER/vectemp
mkdir -p $TMPDIR

EOPBSMID

cat $env >> $pbsfile


if ($QUEUE == share || $QUEUE == casper) then
  cat <<EOSTAIL >> $pbsfile
sh $CMDFILE
EOSTAIL
else
  cat <<EOPTAIL >> $pbsfile
setenv MPI_SHEPHERD true
mpiexec_mpt -n $NTASK launch_cf.sh $CMDFILE
EOPTAIL
endif


## submit job (or not)

if($submit == yes) then
  qsub $pbsfile

  ## PBS gets hosed if it gets more than about 1 job per second.
  ## Sleep 1 second so that we don't make things sad when looping over
  ## many commandfiles.

  sleep 1
endif

exit 0

# Copyright 2018 Univ. Corp. for Atmos. Research
# Author: Seth McGinnis, mcginnis@ucar.edu

