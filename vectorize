#!/bin/tcsh -f

## given a file of commands (one command per line), runs them in
## parallel on cheyenne using commandfile MPMD approach

set defaultq = yes
set help = no
set submit = yes
set QUEUE = economy
set defaulte = yes
set defaultm = yes
# set MEMORY = 2G
set memory = no
set WALLTIME = 00:10:00


## Argument parsing from util-linux-ng getopt-parse.tcsh example.

# Use a temp variable b/c eval nukes getopt return value.  ':q' copies
# argv list w/ no substitutions

set temp=(`getopt -a -n vectorize -s tcsh -o d:e:ghj:m:np:q:sw: --long dir:,env:,help,nosub,memory:,project:,queue:,walltime: -- $argv:q`)
if ($? != 0) then
  echo "Terminating..." >/dev/stderr
  exit 1
endif

# Quote the parens b/c the result is a list, and they need to be
# evaluated when eval is called.  'q' prevents substitutions.

eval set argv=\($temp:q\)

while (1)
  switch($1:q)
  case -d:
  case --dir:
    set dir = $2:q ; shift ; shift
    breaksw;
  case -e:
  case --env:
    set defaulte = no
    set env = $2:q ; shift ; shift
    breaksw;
  case -h:
    set help = yes ; shift
    breaksw
  case -j:
  case --jobname:
    set JOBNAME = $2:q ; shift ; shift
    breaksw;
  case -m:
  case --memory:
    set defaultm = no
    set MEMORY = $2:q ; shift ; shift
    breaksw;
  case -n:
  case --nosub:
    set submit = no ; shift
    breaksw 
  case -p:
  case --project:
    set PROJECT = $2:q ; shift ; shift
    breaksw;
  case -q:
  case --queue:
    set defaultq = no
    set QUEUE = $2:q ; shift ; shift
    breaksw;
  case -w:
  case --walltime:
    set WALLTIME = $2:q ; shift ; shift
    breaksw;
  case --:
    shift
    break
  default:
    echo "vectorize: Internal error!" ; exit 1
    endsw
end


## Check for bad arguments, print usage message

if(! $?PROJECT) then
  set PROJECT = none
  echo "vectorize: ERROR: project code not defined"
endif

if( $#argv < 1) then
  echo "vectorize: ERROR: no commandfile"  
endif

if( $#argv > 1) then
  echo "vectorize: ERROR: too many arguments"
endif

if($help == yes || $PROJECT == none || $#argv != 1) then
  cat <<EOUSAGE
Usage: vectorize [-d dir] [-h] [-j jobname] [-n] [-p project] [-q queue] [-w walltime] cmdfile
  -d, --dir:       directory for output; defaults to \`mktemp -d\`
  -e, --env:       environment file; defaults to ~/.vectorize/<queue>
  -h, --help:      prints this help message
  -j, --jobname:   qsub jobname; defaults to `basename cmdfile .txt`
  -m, --memory:    memory needed per task in GB
  -n, --nosub:     don't submit job, just set everything up
  -p, --project:   project code; defaults to PROJECT envariable (if set)
  -q, --queue:     queue to submit to; defaults to 'economy'
  -w, --walltime:  wallclock limit for job; defaults to 00:10:00
  cmdfile: a file with one command per line, to be run in parallel

  vectorize is a utility for running many independent single-threaded
  commands in parallel on cheyenne using MPDP parallelism.
EOUSAGE
  exit 1
endif

## bail out early if no command file

if (-z $1) then
  echo "vectorize: ERROR: empty command file; exiting"
  exit 1
endif
if (! -e $1) then
  echo "vectorize: ERROR: no such command file: '$1'; exiting"
  exit 1
endif


## Check for bad memory specification, strip optional "GB"
#if($defaultm == no && !($MEMORY =~ ??? )) then
#  echo "vectorize: ERROR: --memory option must be numeric"
#endif 
## stop if memory * 36 > 109 on cheyenne or memory > 1500 on casper


## if not specified, set environment based on queue
if ($defaulte == yes) then
  set env = "~/.vectorize/$QUEUE"
endif

if (! -e $env) then
  if ($defaulte == yes) then
    echo "vectorize: ERROR: no default environment for queue '$QUEUE'; exiting"
    echo "To resolve this error, create file ~/.vectorize/$QUEUE containing"
    echo "any 'module load' commands, etc. needed in the PBS script."
  else 
    echo "vectorize: ERROR: no such environment file: '$env'; exiting"
  endif
  exit 1
endif


## create output dir

if ( $?dir ) then
  mkdir -p $dir
else
  set dir = `mktemp -d`
endif


## figure out how many jobs and split up commandfiles accordingly

if ($QUEUE == share) then
  ## run commandfile in serial as a single job

  set NJOBS = 1

  mkdir $dir/01
  cp $1 $dir/01/cmd

else if ($QUEUE == casper) then 
  ## one job per task; split commandfile into single lines

  set NJOBS = `cat $CMDFILE | wc -l`

  ## repeated code, should refactor...
  set ndigits = `echo -n $NJOBS | wc -c | sed -e 's/$/\n2/' | sort | tail -1`
  split --numeric-suffix=1 -a $ndigits -l1 $1 $dir/cmd.  
  foreach i (`seq -w 01 $NJOBS`)
    mkdir $dir/$i
    mv $dir/cmd.$i $dir/$i/cmd
  end
  unset ndigits

else
  ## on cheyenne

  set ntasks = `cat $CMDFILE | wc -l`

  if ($defaultm == yes) then
    ## no memory requirement = use all 36 CPUs / node
    set NJOBS = `perl -w -e "use POSIX; print ceil($ntasks/36)"`
  else
    ## normal nodes have up to 45 GB memory, large nodes have up to 109 GB
    ## (available of 64 and 128 GB, respectively)
    set taskspernode = `perl -w -e "use POSIX; print floor(109/$MEMORY)`
#    if ($taskspernode < 18) then
#      echo "vectorize: ERROR: less than 50% node utilization; use [flag] to override"
#      exit 1
#    endif
    set NJOBS = `perl -e -w "use POSIX; print(ceil($ntasks/$taskspernode))`
    unset taskspernode
  endif
  unset ntasks

  set ndigits = `echo -n $NJOBS | wc -c | sed -e 's/$/\n2/' | sort | tail -1`
  split --numeric-suffix=1 -a $ndigits -nl/$NJOBS $1 $dir/cmd.
  foreach i (`seq -w 01 $NJOBS`)
    mkdir $dir/$i
    mv $dir/cmd.$i $dir/$i/cmd
  end
  unset ndigits

endif

#### HERE!  Splitting has been done, need to loop over NJOBS subdirs




## setup

if (! $?JOBNAME ) then
  set JOBNAME = `basename $1 .txt`
endif

set CMDFILE = $dir/cmd
set OUTFILE = $dir/out
set ERRFILE = $dir/err
set pbsfile = $dir/pbs



## commands need to be wrapped in a shell invocation for MPMD
## but not for running in share queue or on casper

if ($QUEUE == share || $QUEUE == casper) then
  cp $1 $CMDFILE
else 
  sed "s|\(.*\)|bash -c '\1'|g" $1 > $CMDFILE
endif


# if ($serial == yes) then
# 
#   if ($defaultm == no) then
#     set memstring = ":mem=${MEMORY}GB"
#   else
#     set memstring = ""
#   endif
# 
#   cat <<EOSERIAL >> $pbsfile
# # CPU resource request for serial job in shared queue
# #PBS -l select=1:ncpus=1$memstring
# EOSERIAL
# 
# else


## create PBS batch script

cat <<EOF > $pbsfile
#!/bin/tcsh

##### parameters for PBS scheduling via qsub
##### submit jobs as "qsub scriptname"

# account code to charge to
#PBS -A $PROJECT

# which queue to use
#PBS -q $QUEUE

# job name
#PBS -N $JOBNAME

# stdout file
#PBS -o $OUTFILE

# stderr file
#PBS -e $ERRFILE

# runtime limit
#PBS -l walltime=$WALLTIME

# CPU resource request
# ntask = number of lines in file [$NTASK]
# nnode = ceiling(ntask / 36)     [$NNODE]
# ncpus = ceiling(ntask / nnode)  [$NCPUS]
# select: number of nodes
# ncpus: number of cpus per node to use
# mpiprocs: matches ncpus (1 process per CPU)
# ompthreads: always set to 1 (1 thread per process)
#PBS -l select=${NNODE}:ncpus=${NCPUS}:mpiprocs=${NCPUS}:ompthreads=1

setenv TMPDIR /glade/scratch/$USER/vectemp
mkdir -p $TMPDIR

EOF

cat $env >> $pbsfile


if ($QUEUE == share || $QUEUE == casper) then
  cat <<EOSTAIL >> $pbsfile
sh $CMDFILE
EOSTAIL
else
  cat <<EOPTAIL >> $pbsfile
setenv MPI_SHEPHERD true
mpiexec_mpt -n $NTASK launch_cf.sh $CMDFILE
EOPTAIL
endif


## submit job (or not)

if($submit == yes) then
  qsub $pbsfile
endif

exit 0

# Copyright 2018 Univ. Corp. for Atmos. Research
# Author: Seth McGinnis, mcginnis@ucar.edu
